#+title: ðŸŽ„ Advent_of_code ðŸŽ„

ðŸŽ„ Every Christmas, we muster up the motivation to do AOC again ðŸŽ„

* Table of Contents :TOC:
- [[#year-2024][Year 2024]]
  - [[#tooling-info-for-this-years-advent-of-code][Tooling Info for this year's advent of code]]
  - [[#day-1-2024-12-02-mon-edit-distance-and-similarity-score][Day 1 [2024-12-02 Mon]: Edit Distance and Similarity Score]]

* Year 2024
** Tooling Info for this year's advent of code
I'm just going to use org-babel for this, intending to just use the new python knowledge gained from using the "Fluent Python" book.

*** Fetching the day's inputs
I have an input downloader script at =./io/input_fetcher.sh=.
It looks something like this:
#+begin_src bash
#!/bin/bash

# Check if the correct number of arguments is provided
if [ "$#" -ne 4 ]; then
    echo "Usage: $0 <year> <day> <session_cookie> <output_directory>"
    exit 1
fi

YEAR=$1
DAY=$2
SESSION_COOKIE=$3
OUTPUT_DIR=$4

# Create the output directory if it doesn't exist
mkdir -p "$OUTPUT_DIR"

# Download the input file for the specified year and day
curl "https://adventofcode.com/$YEAR/day/$DAY/input" \
  --cookie "session=$SESSION_COOKIE" \
  -o "$OUTPUT_DIR/${YEAR}_day${DAY}_input.txt"

if [ $? -eq 0 ]; then
    echo "Input for Day $DAY of Year $YEAR downloaded successfully to $OUTPUT_DIR."
else
    echo "Failed to download input for Day $DAY of Year $YEAR."
fi
#+end_src

Here's how to use it:
#+begin_src bash :results output replace
pwd;
./io/input_fetcher.sh 2024 1 <your_session_cookie> ./io/
#+end_src

*** Python Efficient File Reading
Python has a bunch of ways to read files:
1. bufferred reading
2. chunking
3. using a mmap
   - will handle huge files, even those that can't be mapped onto the RAM as well
   - [[https://blog.finxter.com/5-best-ways-to-improve-file-reading-performance-in-python-with-mmap/][here's]] some ways to setup the mmap (e.g. with file-locking)
4. iter over file obj
   - good for text files

#+name: Reader
#+begin_src python :results output :session my_session
class Reader:
    def __init__(self, filename):
        self.filename = filename
        self.url = f"./io/{filename}"
        return

    def apply_fn_to_lines(self, fn):
        with open(self.url) as f:
            return [fn(line) for line in f]

#+end_src

** Day 1 [2024-12-02 Mon]: Edit Distance and Similarity Score
Part 1: get edit distance
This is about a very primitive edit-distance metric. It's all to do with numbers.

Part 2: get similarity score, similarly primitive.

I think this is a good example of python's expressiveness as a language.

#+name: Day 1
#+begin_src python :results output
from collections import Counter

class Solution:
    def reader(self, url):
        with open(url) as f:
            data = f.read()
            split_lines = (line.split() for line in data.split("\n"))
            tups = ((int(line[0]), int(line[1])) for line in split_lines if line)
            left, right = [], []
            for left_val, right_val in tups:
                left.append(left_val)
                right.append(right_val)

            return left, right


    # only to be used for the examples
    def parse_input(self, input):
        split_lines = (line.split() for line in input.split("\n"))

        return ((int(left), int(right)) for left, right in split_lines)

    def transform_input(self, input):
        left, right = [], []
        lines = self.parse_input(input)
        for left_val, right_val in lines:
            left.append(left_val)
            right.append(right_val)

        return left, right

    def get_edit_distance(self, left_vals, right_vals):
        distances = [abs(left - right) for left, right in zip(sorted(left_vals), sorted(right_vals))]

        return sum(distances)

    def get_similarity_score(self, left_vals, right_vals):
        right_counts = Counter(right_vals)
        scores = (val * right_counts[val]  for val in left_vals)

        return sum(scores)

input = \
"""3   4
4   3
2   5
1   3
3   9
3   3"""
url = "./io/2024_day1_input.txt"
s = Solution()
# test small inputs:
small_input = s.transform_input(input)
print(s.get_edit_distance(*small_input))
print(s.get_similarity_score(*small_input))

left, right = s.reader(url)
ans_part_1 = s.get_edit_distance(left, right)
ans_part_2 = s.get_similarity_score(left, right)

print(f'answer for part 1: {ans_part_1}')
print(f'answer for part 2: {ans_part_2}')
#+end_src

